---
layout: post
title:递归算法之求解汉诺塔问题
category: 算法设计与分析
tags: [算法设计与分析]
---

## 递归算法之求解汉诺塔问题

### Java程序代码

```java
import java.util.Scanner;

public class HanoiDemo {
	public static void main(String[] args) {
		long startTime = System.nanoTime();
		char a = 'A';
		char b = 'B';
		char c = 'C';
		System.out.print("请输入汉诺塔盘子数目:");
		Scanner s = new Scanner(System.in);
		int n = s.nextInt();
		s.close();
		System.out.printf("%d个盘片的移动过程：\n", n);
		hanoi(n, a, b, c);
		
	static void hanoi(int n, char a, char b, char c) {
		if (n == 1) {
			System.out.printf("盘片%d： %c → %c\n", n, a, c);
		} else {
			hanoi(n - 1, a, c, b);
			System.out.printf("盘片%d： %c → %c\n", n, a, c);
			hanoi(n - 1, b, a, c);
		}
	}
}
```

### 运行截图

![img](C:\Users\waynechu\Desktop\新建文件夹\1.png)

### 过程分析

递归将难求解的大问题不断分解为新的子问题，从未知向已知推进。这里以个人熟悉的Java虚拟机对方法的递归执行过程进行解释。

1.  首先为执行的移动的两条输出语句打上断点，方便观察每个递归方法执行的过程

![img](C:\Users\waynechu\Desktop\新建文件夹\2.png)

2.  Debug主程序并且输入盘子数目为4，可以观察到执行到第一次断点时，在该程序中除主线程外创建了4个其他线程，这四个线程是递归执行四次`hanoi(n - 1, a, c, b);`产生的，并且每次递归调用时参数都在改变，对应的线程如图所示。

![img](C:\Users\waynechu\Desktop\新建文件夹\3.png)

3.  继续执行程序，能够得到hanoi(1,a,c,b)的解。可以看到控制台输出第一次盘片移动过程，并且该线程被销毁

![img](C:\Users\waynechu\Desktop\新建文件夹\4.png)
![img](C:\Users\waynechu\Desktop\新建文件夹\5.png)

4.  继续执行程序`System.**out**.printf("盘片%d： %c → %c\n", n, a, c); hanoi(n - 1, b, a, c); `，控制台输出第二次盘片移动过程，并且创建新的线程

![img](C:\Users\waynechu\Desktop\新建文件夹\6.png)

![img](C:\Users\waynechu\Desktop\新建文件夹\7.png)

5.  继续执行程序，可以看到输出第三次盘片移动的过程，并且销毁了 hanoi(1,b,a,c) 和 hanoi(2,a,b,c) 对应的两线程，因为 hanoi(2,a,b,c) 方法的子方法为 hanoi(1,a,c,b) 和 hanoi(1,b,a,c)，能够直接求出移动过程

![img](C:\Users\waynechu\Desktop\新建文件夹\8.png)

![img](C:\Users\waynechu\Desktop\新建文件夹\9.png)

6.  继续执行程序，可以看到输出第四次盘片移动过程，并且为 hanoi(3,a,c,b) 方法创建了两个新的线程

![img](C:\Users\waynechu\Desktop\新建文件夹\10.png)

![img](C:\Users\waynechu\Desktop\新建文件夹\11.png)


7.  篇幅原因，省略往下继续执行的过程。从每步执行结果可以得知，Java虚拟机是通过创建新的线程来执行递归的子方法，在这里可以将线程的创建和销毁对应于方法的出栈和入栈来理解。每当方法执行到递归出口时，就销毁该线程。当方法需要分解为子方法时，就为子方法创建相应个数的线程，并且子方法的线程优先级是高于父方法对应的线程。所以在线程的创建和销毁的过程中，完成了对大问题的逐步分解求解过程。但是，递归内存消耗很大。而且，如果递归深度太大，会创建大量的线程，导致Java虚拟机堆栈溢出，严重的话甚至导致系统假死。

8.  比如计算999个盘片的汉诺塔过程，如下图会创建1000个线程（其中一个为主线程）。使用递归虽然可以简化思维过程，效率和开销问题是递归最大的缺点。但是不可否认递归对解描述的直观性以及代码的简洁性，所以了解递归算法的过程，对递归算法的把握及使用场合的选择有重要意义！！！
9.  
  ![img](C:\Users\waynechu\Desktop\新建文件夹\12.png)

10.  下图是4个盘片移动的方法回调步骤，便于分析整个求解过程。

![img](C:\Users\waynechu\Desktop\新建文件夹\13.png)
